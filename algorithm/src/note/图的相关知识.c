/*
图是由顶点的非空有穷集合与顶点之间关系（边或弧）
的集合构成的结构，通常表示为G = (V,E)
其中V为顶点集合，E为关系（边或弧）的集合

无向图就是任意两个顶点之间的关系时双向的，也即
不存在vi到vj但vj不能到vi的边或者弧。
有向图就有方向，一条路径只能单方向流动
通常，无向图的表示形式：
G(V,E)
V:v1,v2,v3,v4...
E:(v1,v2),(v1,v3)...
有向图的表达方式：
G=(V,E)
V:v1,v2,v3,v4...
E:<v1,v2>,<v2,v1>...
一般来说，边上面会有“权”，边上带权的图成为网络。
形象来说，可以认为权是一种长度或者过路费等

顶点的度
依附于某个顶点vi的边的数目，记作TD(vi)
对于有向图来说就有入度和出度，即为ID(vi)和OD(vi)
TD(vi) = OD(vi) + ID(vi)

重要结论
对于具有n个顶点，e条边的图，有：
e = sum(TD(vi))/2
具有n个顶点的无向图最多有n(n-1)/2条边，
具有n个顶点的有向图最多有n(n-1)条边，
这是因为，无向图的边是“同质”的，但有向图的边不同质。
边的数量达最大的是完全图，接近最大的是稠密图，否则称稀疏图


路径
从vi到vj有路径的虫咬条件：存在一系列顶点序列，且序列中相邻
两个顶点构成的顶点偶对分别为图中的一条边
简单路径：顶点序列中顶点不重复的路径。
不带权的图的路径长度就是经过的边的条数，带权就是经过边的
权数总和

子图
很简单，不赘述

图的连通
对于无向图，如果每两个顶点之间都是有路径的（连通的）
那么该无向图就是连通的。
连通分量：无向图中的极大连通子图（注意是子图，有时候
整个图不连通，但是可能存在一个甚至多个连通分量)
有向图的要求更严，必须是每两个顶点之间双向连通，此时
有向图就是强连通的。
强连通分量：有向图中的极大强连通子图。

生成树
包含所有的n个顶点但只有n-1条边的极小连通子图

图的存储
1.邻接矩阵存储法
很简单，用一个二维数组就可以，如下所示：
A[i][j] = (vi到vj有边) ? 1 : 0
对于带权的图
A[i][j] = (vi到vj有边) ? wij(权值) : infinity(无边)
自然，有时候为了更好地反映顶点，有时候就可以直接
把第一个顶点定成1而不是0
由于我们考虑的是简单图，因此A[i][i]一定无边。
2.建立n个线性链表存储该图
首先，每个链表前面设置一个头结点（注意这个结点的类型
和后序结点类型不一样，只是为了突出打头的作用），构造为
vertex（顶点） link
第i个链表中的每一个链接点（称之为边结点）表示以第i个顶点
为出发点的一条边，构造为
adjvex（指向的下一个结点） weight（权重） next
不难得知无向图的边结点的个数一定是偶数，所以如果出现奇数个
边结点，该图就一定是有向图
无论是哪种储存方式，都建议开一个数组保留n个结点。
由以上两种方式很轻松地就可以写出创造一个图的函数，在此就不必记录

图的遍历（重点）
1。深度优先遍历（DFS）
原则：从图中某个指定的顶点出发，先访问顶点v，然后从顶点v未被
访问过的一个邻接点出发，继续进行深度优先遍历，直到图中与v相通
的所有顶点都被访问。如果还有尚未被访问的顶点，那就从这个顶点
按照同样的方式遍历，直到遍历全图。可知这种情况不可能发生连通图上。
算法
void travelDFS(Vlink G[].int n)
{
    int i;
    for(i = 0;i < n;i++)
        Visited[i] = 0;//所有顶点初始的时候都没有被访问
    for(i = 0;i < n;i++)
        if(!Visited[i])
            DFS(G,i);
}
void DFS(Vlink G[],int v)
{
    Elink *p;
    Visited[v] = 1;
    VISIT(G,v);//访问当前结点
    for(p = G[v].link;p != NULL;p = p->next)
    {
        if(!Visited[p->adjvex])
            DFS(G,p->adjvex);
    }
}
算法时间复杂度为O(n+e),n为顶点数，e为边
由于矩阵太简单。这里就只给出了链表存储结构的算法
此时的时间复杂度是经典的o(n2)
2.广度优先遍历(BFS)
原则：从图中某个指定的顶点v出发,先访问顶点v,然后依次访问
顶点v的各个未被访问过的邻接点,然后又从这些邻接点出发, 按照
同样的规则访问它们的那些未被访问过的邻接点，如此下去，直到
图中与v 相通的所有顶点都被访问;若此时图中还有未被访问过的顶点, 
则从另一个未被访问过的顶点出发重复上述过程, 直到遍历全图。
void travelBFS(Vlink G[],int n)
{
    int i;
    for(i = 0;i < n;i++)
        Visited[i] = 0;
    for(i = 0;i < n;i++)
        if(!Visited[i])
            BFS(G,i);
}
void BFS(Vlink G[],int v)
{
    Elink *p;
    VISIT(G,v);
    Visited[v] = 1;
    enQueue(Q,v);//入口的第一个顶点入队,Q是队列
    while(!emptyQ(Q))
    {
        v = deQueue(Q);//取出队头元素
        p = G[v].link;
        for(;p != NULL;p = p->next)
        {
            if(!Visited[p->adjvex])
            {
                VISIT(G,p->adjvex);
                Visited[p->adjvex] = 1;
                enQueue(Q,p->adjvex)//邻接的顶点依次入队
            }
        }
    }
}
、
以上两个方法依次对照树的广度和深度遍历。

最小生成树
在图无权的时候，最小生成树的定义就和生成树一样：在图有权的时候，
最小生成树就是指那些权值之和最小的生成树（有可能有多颗）。
构造算法
1.Prim算法
设G=（V，GE）为具有n个顶点的带权连通图，T=（U,TE）为生成的最小生成树
初始时，TE为空，U={v}，v属于V。
依次在G中选择一条一个顶点仅在V中，另一个顶点在U中。并把权值最小的边加入
集合TE，同时将该边仅在V中的那个顶点加入集合U。重复上述过程n-1次，使得
U=V，此时T为G的最小生成树

#define MAXVER  512
#define INFINITY   32767
void Prim(int  weights[][ MAXVER], int n, int src, int edges[ ])
{ //weights为权重数组(带权值的邻接矩阵）、n为顶点个数、src为最小树的第一个顶点
    int minweight[MAXVER], min;    // i,edges[i]为最小生成树边，minweight存放已确定的生成树T上的顶点至未确定的最小生成树上顶点i（在G中，
//但还不在T中）的最小权重。若minweight[i] = k, 则已确定的生成树上顶点至未确定的树上顶点i的权重为k。minweight[i] = 0 表示顶点i已确定为最小生成树顶点。
//如果edge[i] = j,则表示已确定生成树的顶点j到非生成树的顶点i权值最小，相应的权值就存在minweight中，最终edge存的就是生成的最小生成树的边。
    int i, j, k;
    for(i=0; i<n; i++){  //初始化相关数组
        minweight[i] = weights[src][i];  //将src顶点与之有边的权值存入数组
        edges[i]  = src;  //初始化第一个顶点为src
     }
    minweight[src]  = 0;   //将第一个顶点src顶点加入生成树,0表示为相应下标的顶点已加入生成树
    for(i=1; i< n; i++){
        min = INFINITY;
        for(j=0, k=0;  j<n; j++)
            if(minweight[j] !=0 && minweight[j] < min) {  //在数组中找最小值，其下标为k
                min = minweigth[j];  k = j;
            }
        minweight[k] = 0;  //找到最小生成树的一个新顶点
        for(j=0;  j<n; j++)  // 依次检查新加入的顶点k到未加入的顶点之间的权值
             if(minweight[j] != 0 && weights[k][j] < minweight[j] ) {  
                  minweight[j] = weights[k][j]; //找到kj边权值比已加入顶点到j的值小则替换
                  edges[j] = k;   //将边(j,k)信息存入边数组中
             }
    }
} 
2.Kruskal算法
G=(V,GE),T=(U,TE),初始时，TE为空，U=V
从G中选择一条当前未选择过的、且边上的权值最小的边加入TE，若加入TE后使得T未产生回路,则本次选择有效，
如使得T产生回路,则本次选择无效,放弃本次选择的边。重复上述选择过程直到TE中包含了G的n-1条边，此时的T为G的最小生成树。 
 
//Kruskal（克鲁斯卡尔算法）生成最小生成树
void guibing(int i,int j)
{
	int m1,m2;
    m1 = MAX(f[i],f[j]);
    m2 = MIN(f[i],f[j]);
    for(int i1 = 0;i1 < N;i1++)
        if(f[i1] == m1)
            f[i1] = m2;
}//这里的核心作用就是用来并和两个集合。简单的办法就是，对于每个点，我们首先认为它们刚开始只属于自己，
也即f[i] = i，然后，图中给的边可以把两点连接在一起，这时候这两个点就属于一个集合了，为了方便，我们将
f[i1],f[i2]中较小的那一个作为新的集合名字。但是有一种可能，就是较大的那一个不只是一个元素而是一个集合，
因此并和的时候需要将所有的f[i] = max(f[i1],f[i2])转换成min(f[i1],f[i2])。简单地来说如下图所示:
x:     0 1 2 3 4
f[x]:  0 1 2 3 4
现在连接0,1,则f[x]变为：
0 0 2 3 4
现在连接2，3，则f[x]变为：
0 0 2 2 4
现在连接1，2，则f[x]变为：
0 0 0 0 4
这样我们就可以通过检查f[i1] ?= f[i2] 来判断两个元素是否在同一个集合里面了，这是更一般的并查集，将该思想
用于Kruskal算法中将会大大简便时间复杂度和代码复杂度。

void kruskal()
{
    int time = 0;
    for(int i1 = 0;i1 < E;i1++)
    {
        int i = route[i1].v1;
        int j = route[i1].v2;
        if(f[i] == f[j])
            continue;
        else
        {
            SUM += route[i1].weight;
            sequence[s++] = route[i1].line;
            time++;
            guibing(i,j);
            if(time == E)
                break;
        }
   }
}

最短路径问题（重点！）
图不带权时，路径长度指经过的边的数目
图带权时，路径长度指经过边的权值之和
由此不难推出最短路径的含义。
为实现最短路径的寻找问题，我们采用另外一种数据结构
A[i][j] = 0(if i == j) ,wij(i 到 j有边，wij为权值)，INFINITY（i，j无边）
再设置一个标志数组wfound[0...n-1]记录源点v到图中哪些顶点的最短路径已经找到，
wfound[i] = 1,也即v到i的最短路径已经找到，否则未找到。
初始时，wfound[v] = 1,wfound[i] = 0(i != v)，很显然，v到v的距离肯定最短，
所以已经找到最短路径；
再设置Sweight[0...n-1]分别记录v到图中各顶点的最短路径的长度，其中Sweight[i]记录
源点到顶点i的最短路径长度。初始时，Sweight数组的值为邻接矩阵第v行的n个元素值
也就是先假设v到各个顶点的距离已经是最短的，接下来再不断调整。
设置数组Spath[0...n-1]分别记录源点v到图中各顶点的最短路径所经过的顶点序列，其中
Spath[i]记录源点到顶点i的路径。初始时，Spath[i][0] = {v}
Dijkstra算法的核心思想就是，先确定一个当前距离源点v最近的顶点u，并且wfound[u] = 1,
再将顶点u加入Spath[u][]。现在在加入了u的基础上，重新计算目前可能存在的最短路径，
也即，在通过源点v并且要经过u的情况下，看看这时候到其他顶点的路径长度有没有变化，
计算方式就是v到u的权值加上u到其他顶点的权值，如果这个距离小于原先直接从源点到其他
顶点的距离，那么就用这个长度代替原有的长度，并且还要修改相应的Spath。
只需要不断重复这个过程，就可以得到最短路径。需要注意的是，Dijkstra算法不支持负权图。

#define length 100
void SHORTEST_PATH(int weight[i][j],int v,int n,int Sweight[],int Spath[][length])
{
    int i,j,u,count,wfound[length],path[n],p;//count用于记录跑了几次循环，
    //path数组储存的是每个结点当前到出发点最短路径所需要的的点的个数(作为Spath的下标使用),
    //p是当前遍历的结点
    int minweight;
    for(i = 0;i < n;i++)
    {
        wfound[i] = 0;
        Sweight[i] = weight[v][i];
        Spath[i][0] = v;
        path[i] = 1;//0位已经是v，所以要从1位开始
    }
    wfound[v] = 1;
    count = 1;
    while(count < n)
    {
        minweight = INFINITY;
        for(j = 0;j < n;j++)
        {
            if(!wfound[j] && (Sweight[j] < minweight))
            {
                minweight = Sweight[i];
                u = j;
            }
        }
        wfound[u] = 1;
        Spath[path[u]++] = u;
        for(j = 0;j < n;j++)
        {
            if(minweight + weight[u][j] < Sweight[j])
            {
                Sweight[j] = minweight + weight[u][j];
                for(int i1 = 0;i1 < path[u];i1++)
                    Spath[j][i1] = Spath[u][i1];
                path[j] = path[u];
                //举个简单的例子，有三个站点，分别是1，2，3，两两相通，
                //但是从1到2再到3的距离比从1到3的距离短（几何上不可能，这里的
                //“距离”指权值），在第一遍遍历的时候，可知储存着的从1到2，3的最短路径
                //组合分别是1-2,1-3,但是因为最短路径尚未确定，因此都先记为1-,1-,
                //也即对应的是Spath[2][0] = 1,Spath[3][0] = 1;
                //此时的path[2] = 1,path[3] = 1,也就是下一个可能储存进来的结点的下标，
                //然后又发现1到2的权值比1到3的权值更小，因此选择1-2，但是在这时又发现
                //1通过2再到3的距离要更短(也即minweight + weight[2][3] < Sweight[3])
                //于是这条路径比1直接到3更优秀，所以需要更新路径，此时就有Spath[3][path[3]] = u，
                也即从1到3目前的最短路径：1-2-3。
            }
        }
    }
}
*/