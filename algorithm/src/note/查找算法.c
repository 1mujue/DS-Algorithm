#include <stdio.h>
#define M 1000
typedef int keytype;

int binsearch(keytype key[], int n, keytype k);
int binsearch2(keytype key[], int low, int high, keytype k);
void insertSort(int array[], int n);

int main()
{
    int a[8] = {49,38,65,97,76,13,47,50};
    insertSort(a,8);
    return 0;
}

int binsearch(keytype key[], int n, keytype k)
{
    int low = 0, high = n - 1, mid;
    while (low <= high)
    { // 查找结束的条件
        mid = (low + high) / 2;
        if (k == key[mid])
            return mid; /*  查找成功  */
        if (k > key[mid])
            low = mid + 1; /*  准备查找后半部分 */
        else
            high = mid - 1; /* 准备查找前半部分 */
    }
    return -1; /*   查找失败  */
}

int binsearch2(keytype key[], int low, int high, keytype k)
{
    int mid;
    if (low > high)
        return -1; // 注意返回值
    else
    {
        mid = (low + high) / 2;
        if (k == key[mid])
            return mid;
        else if (k < key[mid])
            return binsearch2(key, low, mid - 1, k);
        else
            return binsearch2(key, mid + 1, high, k);
    }
}

void insertSort(int array[], int n)
{
    int temp;
    int times = 0;
    for (int i = 1; i < n; i++)
    {
        int low = 0;
        int high = i - 1;
        temp = array[i];

        while (high >= low)
        {
            times++;
            int mid = (low + high) / 2;
            if (array[mid] > temp)
                high = mid - 1;
            else
                low = mid + 1;
        }
        printf("%d ",times);
        times = 0;
        for (int j = i - 1; j > high; j--)
            array[j + 1] = array[j];
        array[high + 1] = temp;
    }
}

//B树，用于查找比较方便（核心思想是索引查找）
//一个m阶的B树是满足下列条件的m叉树：
/*1.每个分支结点最多有m棵子树，除根节点外，最少有
[m/2]棵子树，根节点最少有2棵子树（除非根节点是叶结点结点）
2.所有的“叶结点”都在同一层上，这里的叶结点实际上只是
一种假想的结点，稍后会做出解释。
3.每个分支结点应该包括如下信息：
n  p0,key1,p1,key2,...,keyn,pn
其中n是代表该结点中的关键字次数，然后因为m阶B树最多有
m棵子树，这些子树都是由pi指向，因此不难得出一个结点最多
有m-1个关键字，也即n <= m - 1.而关键字也是升序排列的，也即
keyi < keyi+1.
4.查找方式：首先将给定的关键字k在B-树的根结点的关键字集合中
采用顺序查找法或者折半查找法进行查找，若有k=keyi , 则查找成功，
根据相应的指针取得记录。否则，若kkeyi,则在指针pi-1所指的结点
中重复上述查找过程，直到在某结点中查找成功，或者有pi-1=NULL，查找失败。
注意：因为在查找中，想要获取被查找元素所在子树信息（假设该元素
并不在本层的关键字中出现），就需要找到一个keyi，使得n < keyi，然后就可以定位
子树为pi-1指定的子树，但是有可能被查找元素十分巨大，因此我们还需要在
最末尾定义一个keyMax，这样查找时进入的子树就会是pn指向的子树了。
*/
//类型定义
#define Maxkey 1000
typedef struct node
{
    int keynum;
    keytype key[M + 1];//最右边是MaxKey
    struct node *ptr[M + 1];
}BNode;

keytype searchBTree(BNode *t,keytype k)
{
    int i,n;
    BNode *p = t;
    while(p != NULL)
    {
        n = p->keynum;
        p->key[n + 1] = Maxkey;
        i = 1;
        while(k > p->key[i])
            i++;
        if(p->key[i] == k)
            return p->key[i];
        else
            p = p->ptr[i - 1];
    }
    return -1;
}

//B树的插入
/* 若将k插入到某结点后使得该结点中关键字值数目超过m-1时，
则要以该结点位置居中的那个关键字值为界将该结点一分为二,
产生一个新结点，并把位置居中的那个关键字值插入到双亲结点中;
如双亲结点也出现上述情况,则需要再次进行分裂。最坏情况下,
需要一直分裂到根结点，以致于使得B树的深度加1。
但是考虑到算法的复杂性，以及B树删除算法的复杂性，在此就不做说明*/

//B+树（阐述定理即可）
/*一个m阶的B+树是满足以下条件的m叉树：
1.每个分支结点最多有m棵子树
2.除根节点，每个分支节点最少有[m/2]棵子树
3.根节点最少有两棵子树（除非根为叶结点结点，此时
B+树就只有一个结点）
4.具有n棵子树的结点中一定有n个关键字
5.叶结点中存放记录的关键字及其指向记录的指针，
或者数据分块后每块最大的关键字值以及指向该块的‘
指针，并且叶结点按关键字值的大小顺序连接成线性链表
key1 p1 key2 p2 key3 p3 ... keyn pn
6.所有分支节点可以看成索引的索引，节点中仅包含它的各个孩子
结点中最大（或最小）关键字值和指向孩子结点的指针。
而且，B+树有两个入口，另外一个入口在最底层（也即所有数据所在地
，此时这一层的结点需要用链表连接起来）
B-树与B+树的区别
1.B-树的每个分支结点中含有该结点中关键字值的个数,B+树没有；
2.B-树的每个分支结点中含有指向关键字对应记录的指针，而B+树只有
叶结点有指向关键字值对应记录的指针
3.B-树只有一个指向根节点的入口，而B+树的叶结点被连接成一个
不等长的链表， 因此，B+树有两个入口，一个指向根结点，另
一个指向最左边的叶结点(即最小关键字所在的叶结点)
*/

//散列(hash)查找
/*为了更高效地进行查找，我们希望找到一种不经过任何关键字
的值的比较（尤其是字符串会浪费很多时间）或者经过很少次的关键字值的比较
就能查找到的方法？->建立记录的关键字与储存位置之间的关系！
A = H(k)
其中，k 为记录的关键字，H(k)称为散列函数，或哈希(Hash)函数，或杂凑函数。
函数值A为k对应的记录在查找表中位置。
散列冲突：两个不同的关键值经过哈希函数的处理之后具有相同的散列地址！
H(ki) = H(kj)

散列表：
以加速查找为主要目的，根据构造的1）散列函数与2）处理冲突的方法将一组关键字映射到一个
3）有限的连续地址集合上，并以关键字在该集合中的“象”作为记录在集合中的存储位置，
按照这种方法组织起来的表文件称为散列表 ,或哈希表, 或称杂凑表 ;建立文件的过程
称为哈希造表或者散列，得到的存储位置称为散列地址或者杂凑地址。
建立散列表的三步骤：
1。确定散列的地址空间（地址范围，散列表长度）
2.构造适合的散列函数
3.选择并指定一种处理冲突的方法

散列函数的构造原则：
1.散列函数的定义域必须包括将要存储的全部关键字；若散列表允许有m个位置时，则函
数的值域为[0 .. m–1](地址空间)。
2.利用散列函数计算出来的地址应尽可能均匀分布在整个地址空间中。
3.散列函数应该尽可能简单，应该在较短的时间内计算出结果.
常见散列函数的构造方法：
1.直接定址法：H(k) = k - 99000 注意：不一定全部都是99000
2.数字分析法：H(k) = ak + b(一般形式)
3.平方取中法（地址容易分散）
4.叠加法
5.基数转换法
6.除留余数法 H(k) = k MOD p，如果m为地址范围的大小，那么p可以为
小于等于m的指数。->散列地址范围：[0...m - 1]

处理散列冲突的办法：
1.开放地址法
所谓开放地址法是将散列表中的“空”地址向处理冲突开放。即当散列表未满时，
处理冲突需要的“下一个”地址在该散列表中解决。
Ai = (H(k) + di) MOD m，i = 1,2,3...
其中H(k)为哈希函数，m为表长，di为地址增量，有：
(1).di = 1,2,3,...,m - 1，称为线性探测再散列
(2).di = 1^2,-1^2,2^2,-2^2...称为二次探测再散列
(3).di = 伪随机数序列 称为伪随机再散列
不难看出，线性探测再散列的优点是保证了地址的利用率，
但问题是如果发生冲突的周围一片地址都已被占用，那么找到
下一个空位置将需要很多时间；二次探测再散列找空位就十分快速
，但是很容易造成一堆空地址；伪随机再散列的性能难以评价。
显然需要建立一个表来储存所有的di，这样才能与Keyi对应，才能
正确地找到相应的地址
2.再散列法
Ai = Hi(k)，也即有很多个hash函数
3.链地址法
将所有发生哈希冲突的关键字构成一个链表，其头指针就是原本所在
地址。此时，原来的数组就可以理解成为一个储存了很多链表的数组，
而每个链表都是当前地址所对应的元素，有点像索引。

平均查找长度(ASL):
找到对应元素所需要的平均比较次数。所谓平均，也就是将查找到每一个
元素所需要比较的次数相加，然后再除以元素个数，比如采用顺序查找查找
一个长度为n的表，不难发现对于第i个元素，一共需要比较i次，因此总比较
次数为n * (n + 1) / 2，然后除以n，就得平均查找长度(n + 1) / 2。
特别的，对于二叉查找法而言，ASL = (n + 1) / n * log2(n + 1) - 1
，不过在题目中一般可以直接数，如1,2,3,4,5,6,7,8,9
因为二叉查找实则是一种树的查找，因此可以化为:
         5
      2     7
     1 3   6 8
        4     9
可知搜索元素在第i层，搜索到该元素就需要比较i次，因此总的比较次数为
1 * 1 + 2 * 2 + 4 * 3 + 2 * 4 = 25,有9个元素，因此ASL = 25/9*/